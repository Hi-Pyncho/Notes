КОМАНДЫ GIT

ПЕРВОНАЧАЛЬНАЯ НАСТРОЙКА
git config --global user.name "[имя]"
git config --global user.email "[адрес электронной почты]"

-----------------------------------------------------
HELP
git help commandName (покажет справку по команде)
git help checkout

-----------------------------------------------------
НАСТРОЙКА SSH(Secure SHell)
Это сетевой протокол, позволяющий производить удаленное управление операционной системой и безопасно передавать данные в незащищенной среде
ls -al ~/.ssh (посмотреть все ключи на компьютере. если нет, то сгенерировать). Потом добавить на gitHub и можно будет коммитить без ввода ключа и пулл реквеста

-----------------------------------------------------
GIT COMMIT
git commit -a -m 'commit message'
Это тоже самое что последовательное (git add .) + (git commit -m 'message')
Но это добавляет только modified файлы в отслеживаемую зону и коммит. Не добавляет untraked файлы

git commit --amend -m 'new commit message'
Дополняет последний коммит, добавляя в него свежие изменения. Меняет сообщение коммита и хеш коммита. Новый коммит не создается!
Можно совместить параметры
git commit -a --amend -m 'new commit message'
также можно без параметра сообщения
git commit -a --amend
git commit --amend --no-edit (добавить изменения в последний коммит без изменения сообщения коммита)

-----------------------------------------------------
GIT DIFF
git diff - показывает разницу между неотслеживаемым состоянием и последним снимком репозитория
git diff --staged - показывает разницу между текущим отслеживаемым состояниям и предыдущим остлеживаемым состоянием
git diff COMMIT_ID - разница между текущим состоянием и указанным снимком

-----------------------------------------------------
GIT LOG
git log
git log --oneline (показывает хеши и коммиты в одну строку)
git log --oneline --all (показывает все коммиты)
git log --oneline --all --graph (покажет коммиты в виде графа)
git log -1 (показывает последний коммит. -N - покажет последние N коммитов)
git log --follow [файл] (История изменений конкретного файла, включая его переименование)
git fileName -p hashCommit (выводит состояние файла в определенном коммите в читаемом формате (-p))

-----------------------------------------------------
GIT SHOW
git show [коммит] (Выводит информацию и показывает изменения в выбранном коммите)
git show -num (показывает информацию о коммитах в обратном порядке)

-----------------------------------------------------
GIT CHECKOUT
Перемещение HEAD
При перемещении HEAD находится в состоянии DETACHED, отделен от актуальной версии проекта. Любые изменения или коммиты в этом состоянии удаляются сборщиком мусора при переходе к другому коммиту. И нельзя увидеть из текущего коммита следующие коммиты. Только вернувшись на актуальный слепок
Обратный переход к актульной версии: git checkout <nameBranch>
git checkout master^ - на первого родителя ветки мастер
git checkout master^^ - на прародителя
git checkout HEAD^

git checkout HEAD^ - перемещение на предыдущий коммит
git checkout HEAD~num - перемещение на num коммитов назад

Также можно откатить изменения последнему коммиту в определенном файле. Работает только для untraked и modified изменений
git checkout -- file
(можно git checkout file)
Если изменения уже tracked, то вернуть к untraked можно через git reset
Две черты( -- ) указывают, что после них идет обычный текст (или путь), а не команда или параметр для команды. Лучше их ставить
Также можно откатить изменения до коммита в определенном файле
git checkout <hash/relativeLink> -- fileName (можно передавать несколько файлов)

-----------------------------------------------------
Branch Forcing - перемещение ветки
git branch -f master HEAD~3 - переместит ветку master на три родителя назад от HEAD

-----------------------------------------------------
Отмена изменений RESET
Не удаляет Untraked файлы. Даже в режиме --hard. Но если попадет в отслеживаемую зону, то удалится
3 режима (без указания режима - будет mixed):
--soft (переводит в отслеживаемую зону)
--mixed (переводит последующие коммиты в неотслеживаемую(unstaged)зону)
--hard (удаляет коммиты безвозвратно)
git reset (все равно что git reset --mixed HEAD) - то есть он переводит все после предущего коммита с HEAD в Unstaged
git reset --hard - удалит все неотслеживаемые изменения (but it cannot do hard reset with paths)
git reset HEAD~1 - отмена последнего коммита и перемещение к предыдущему
! - не делай git reset <commit #n> после того, как опубликовал измненения после <commit #n>
Если нужно исключить определенный файл из индексации и отдельно закоммитить его, то
git reset HEAD fileName

-----------------------------------------------------
GIT CLEAN
В отличие от RESET позволяет удалять untraked файлы
git clean -n (покажет какие файлы будут удалены)
git clean -f (удалит untraked файлы)

-----------------------------------------------------
GIT REMOVE
git rm fileName (удалит файл)
После появится git status 'file deleted'. это можно закоммитить в предыдущий коммит
git commit --amend --no-edit 
Также можно только удалить из коммита файл, а сам файл оставить
git rm --cached fileName (появится в отслеж зоне что файл удален, плюс в неостлеж что файл untraked)

-----------------------------------------------------
GIT REVERT - работает на локальных ветках и репозиториях
git revert HEAD - отменяет изменения, создает новый коммит, где будут эти самые изменения

------------------------------------------------------
Удаленные репозитории
git remote -v (просмотр списка существующих удал-х репозиториев)
git remote add REPO_NAME REPO_ADRESS (Добавляет название-закладку для адреса)
git remote add origin https://github.com/Hi-Pyncho/PracticeGit.git 
git remote remove REPO_NAME

git push REPO_NAME branch
git push origin master

Есть локальные ветки(изменяются самим пользователем) и remote ветки (изменяются другими пользователями)
На компьютере хранятся локальные (localBranch) и remote ветки (origin/master ...). Когда мы совершаем pull, то обновляем свои remote ветки. И потом сливаем remote ветку с текущей локальной веткой
git pull origin master
В итоге git pull это:
1) git fetch (скачивает, но не производит актуализацию локальной ветки)
2) git merge origin/master (актуализирует скачанную remote ветку с текущей)

git fetch ssh/http/origin branchName (достать изменения из определенной ветки)
если этой ветки нет локально, то нужно создать новую ветку и закрепить за ней удаленную
git checkout -b branchName origin/branchName

Чтобы не прописывать постоянно git pull origin master, можно привязать локальную ветку к удаленной
git branch --set-upstream-to=origin/master
Теперь можно писать просто git push или git pull
Также можно посмотреть, какие локальные ветки связаны с удаленными
git branch -vv
Еще можно связать remote ветку с локальной при пуше
git push -u origin branchName (-u === --set-upstream)

git clone - вместо git init / git remote ...
клонирует главную ветку
git clone ssh/https <dirName>

---------------------------------------------------------
ВЕТКИ
git branch some-feature (создать ветку с именем)
git branch (список локальных веток)
git branch -v (список локальных веток + инфа)
git branch -d branchName (удаление ветки)
git branch -D branchName (удаление ветки, даже не смерженной ни с чем)
git branch -r (получим список remote веток)
git branch -m newBranchName (переименовать текущую ветку)

git checkout -b branchName (создать и переместить на новую ветку)

git merge nameBranch (находясь на ветке master)
git merge nameBranch -m 'commit message'
git merge --abort (отменяет слияние)

Если в нашей ветке файл удален, а в сливаемой нет, то при конфликте можно либо оставить удаленным, либо восстановить его 
git add fileName

fast-forward merge (когда в master не было изменений, без конфликтов и когда git легко сливает ветки, не создается отдельный коммит для слияния merge commit)

git pull - добавит в локальные remote ветки все недостающие ветки с репозитория
чтобы продолжить развивать конкретную ветку, выполняем
git checkout branchName (создается новая ветка и туда сливаются коммиты из origin/branchName)
git remote show origin (свяжется с репозиторием, покажет списком remote, локальные ветки, проверит, есть ли различия и нужно ли обновить)

git push --delete origin coolFunction (удалит remote ветку с репозитория)
git push origin :oldBranch (удалит remote ветку)
git push origin cmments:comments (отправит текущую ветку cmments в remote ветку comments)

---------------------------------------------------------
CHERRY-PICK
Копирует несколько коммитов на место, где находишься(HEAD) + переместит его после HEAD
git cherry-pick <Commit1> <Commit2> <...>
git rebase -i HEAD~4 (выберет коммиты до нужно коммита. теперь можно выбрать коммиты для rebase)

---------------------------------------------------------
TAG
Можно создавать тэги, которые ссыллаются на опредленный коммит. Даже если хэш коммита изменится, то тэг нет
При checkout на тэг => HEAD detached
git tag [tagName] [commit]
git tag [tagName] (тэг присвоится HEAD)

---------------------------------------------------------
DESCRIBE
git decribe --tags (покажет сколько до ближайшего дальнего тэга)

---------------------------------------------------------
STASH
Если не нужно пока фиксировать наработки, можно спрятать в спец хранилище
git stash (или git stash save)
git stash list (посмотреть список)
git stash apply (восстановит последнее спрятанное изменение)
git stash apply stash@{num} (восстановит нужное изменение)

2
1
3