КОМАНДЫ GIT

ПЕРВОНАЧАЛЬНАЯ НАСТРОЙКА
git config --global user.name "[имя]"
git config --global user.email "[адрес электронной почты]"

-----------------------------------------------------
НАСТРОЙКА SSH(Secure SHell)
Это сетевой протокол, позволяющий производить удаленное управление операционной системой и безопасно передавать данные в незащищенной среде
ls -al ~/.ssh (посмотреть все ключи на компьютере. если нет, то сгенерировать). Потом добавить на gitHub и можно будет коммитить без ввода ключа и пулл реквеста

-----------------------------------------------------
GIT COMMIT
git commit -a -m 'commit message'
Это тоже самое что последовательное (git add .) + (git commit -m 'message')
Но это добавляет только modified файлы в отслеживаемую зону и коммит. Не добавляет untraked файлы

git commit --amend -m 'new commit message'
Дополняет последний коммит, добавляя в него свежие изменения. И меняет сообщение коммита. Новый коммит не создается!
Можно совместить параметры
git commit -a --amend -m 'new commit message'
также можно без параметра сообщения
git commit -a --amend

-----------------------------------------------------
GIT DIFF/LOG
git diff - показывает разницу между неотслеживаемым состоянием и последним снимком репозитория
git diff --staged - показывает разницу между текущим отслеживаемым состояниям и предыдущим остлеживаемым состоянием
git diff COMMIT_ID - разница между текущим состоянием и указанным снимком

git log
git log --follow [файл] (История изменений конкретного файла, включая его переименование)
git show [коммит] (Выводит информацию и показывает изменения в выбранном коммите)

-----------------------------------------------------
GIT CHECKOUT
Перемещение HEAD
При перемещении HEAD находится в состоянии DETACHED, отделен от актуальной версии проекта. Любые изменения или коммиты в этом состоянии удаляются сборщиком мусора при переходе к другому коммиту. И нельзя увидеть из текущего коммита следующие коммиты. Только вернувшись на актуальный слепок
Обратный переход к актульной версии: git checkout <nameBranch>
git checkout master^ - на первого родителя ветки мастер
git checkout master^^ - на прародителя
git checkout HEAD^

git checkout HEAD^ - перемещение на предыдущий коммит
git checkout HEAD~num - перемещение на num коммитов назад
git checkout HEAD@{num} - перемещение на num коммитов вперед

Также можно не просто смотреть, а вернуть файлы к состоянию любого коммита
git checkout <commit> -- path_to_file path_to_file2
Также можно откатить изменения последнему коммиту в определенном файле. Работает только для untraked и modified изменений
git checkout -- file
(можно git checkout file)
Если изменения уже tracked, то вернуть к untraked можно через git reset
Две черты( -- ) указывают, что после них идет обычный текст (или путь), а не команда или параметр для команды. Но лучше их ставить
Также можно откатить изменения до коммита в определенном файле
git checkout <hash/relativeLink> -- fileName

-----------------------------------------------------
Branch Forcing - перемещение ветки
git branch -f master HEAD~3 - переместит ветку master на три родителя назад от HEAD

-----------------------------------------------------
Отмена изменений RESET
Не удаляет Untraked файлы. Даже в режиме --hard. Но если попадет в отслеживаемую зону, то удалится
3 режима (без указания режима - будет mixed):
--soft (переводит в отслеживаемую зону)
--mixed (переводит последующие коммиты в неотслеживаемую(unstaged)зону)
--hard (удаляет коммиты безвозвратно)
git reset (все равно что git reset --mixed HEAD) - то есть он переводит все после предущего коммита с HEAD в Unstaged
git reset --hard - удалит все неотслеживаемые изменения (but it cannot do hard reset with paths)
git reset HEAD~1 - отмена последнего коммита и перемещение к предыдущему
! - не делай git reset <commit #n> после того, как опубликовал измненения после <commit #n>

-----------------------------------------------------
GIT CLEAN
В отличие от RESET позволяет удалять untraked файлы
git clean -n (покажет какие файлы будут удалены)
git clean -f (удалит untraked файлы)

-----------------------------------------------------
GIT REVERT - работает на локальных ветках и репозиториях
git revert HEAD - отменяет изменения, создает новый коммит, где будут эти самые изменения

------------------------------------------------------
Удаленные репозитории
git remote -v (просмотр списка существующих удал-х репозиториев)
git remote add REPO_NAME REPO_ADRESS (Добавляет название-закладку для адреса)
git remote add origin https://github.com/Hi-Pyncho/PracticeGit.git 
git remote remove REPO_NAME

git push REPO_NAME branch
git push origin master

Есть локальные ветки(изменяются самим пользователем) и remote ветки (изменяются другими пользователями)
На компьютере хранятся локальные (localBranch) и remote ветки (origin/master ...). Когда мы совершаем pull, то обновляем свои remote ветки. И потом сливаем remote ветку с текущей локальной веткой
git pull origin master
В итоге git pull это:
1) git fetch (скачивает, но не производит актуализацию локальной ветки)
2) git merge origin/master (актуализирует скачанную remote ветку с текущей)

git clone - вместо git init / git remote ...
клонирует главную ветку
git clone ssh/https <dirName>

---------------------------------------------------------
ВЕТКИ
git branch some-feature (создать ветку с именем)
git branch (список локальных веток)
git branch -v (список локальных веток + инфа)
git branch -d branchName(удаление ветки)
git branch -r (получим список remote веток)

git checkout -b branchName (создать и переместить на новую ветку)

git merge nameBranch (находясь на ветке master)

fast-forward merge (когда в master не было изменений, без конфликтов и когда git легко сливает ветки, не создается отдельный коммит для слияния merge commit)