## REBASE
Берет все коммиты из одной ветки и применяет поверх другой. Создается новый коммит с rebase

Можно смержить с той веткой, на которую делали rebase
`git rebase master` (текущую ветку передвигает после master)  
`git rebase -i master` (выбирает несколько коммитов и передвигает после master)  
`git checkout master; git merge rebaseBranch`  

Также можно явно указать, какую ветку и куда переносить  
`git rebase main feature`  (переместить __feature__ на верхушку __main__, что эквивалентно `git checkout feature + git rebase main`)

Можно отменить  
`git rebase --abort`

При кофликте решаем конфликт, потом  
`git add fileName`
`git rebase --continue` (или  `--skip` - пропускает текущий коммит)

`git checkout master; git rebase branchName` (делает ветку плоской и поднимаем master)

Также git сохраняет ссылку на предыдущее положение HEAD  
`cat .git/ORIG_HEAD`  
Либо можно посмотреть предыдущее положение ветки в __reflog__  
`git reflog feature`  
`git reset --hard feature@{1}`  

И уже совершенный rebase можно отменить и вернуться обратно  
`git reset --hard ORIG_HEAD` (но тут не всегда работает, так как HEAD мог перемещаться)
Или же
`git reflog branchName -1 `(покажет последнее изменение, что rebase branchName произошел в другую ветку)  

`git show --quiet branchName@{1}` (покажет туда, где был предудщий HEAD перед rebase)

`git reset --hard feature@{1}` (отменит rebase и вернется к предыдущему состоянию)

Минус __rebase__ в том, что изменения из __main__ могут сломать всю ветку, в то время как при __merge__ ломается только коммит слияния. В __rebase__ есть флаг `-x` для выполнения команды при ребазировании (например, команда с тестами)  
`git rebase -x 'test command' main`  

Если нужно перенести отдельную ветку (например, когда ветка в ветке) и находясь на нужной ветке, то  
`git rebase --onto main feature`  или  
`git rebase --onto main @~2`  
(то есть перенести ветку __fix__, которая начинается с конца __feature__ на ветку __main__), иначе перенесутся ветки __feature__ и __fix__, которые отходят от __main__  
Если не нужно переносить, то можно копировать через __cherry-pick__


## Интерактивный rebase
`git rebase -i main`  
Тут можно выбирать, какие действия на каждом шаге предпринимать.  
Например, при __edit__ можно полностью изменить коммит и даже разбить его на два через `git reset @~` и заново закоммитить каждое изменение.  
После чего продолжает перебазирование `git rebase --continue`  
В процессе можно поменять логику выполнения __rebase__ `git rebase --edit-todo`  

Отличие __fixup__ от __squash__ в том, что во время шага объединения при __fixup__ заголовок этого коммита комментируется.  

Также можно просто переписать историю ветки через __rebase__  
`git rebase -i @~3` - позволит исправить три последних коммита  
Также можно переписать всю ветку - нужно в качестве аргумента передать общего родителя, начало расхождения ветки с другой веткой.  

Если нужно исправить конкретный коммит в середине ветки, то сначала создаем новый коммит-заплатку  
`git commit -a --fixup=@~~`  
После чего создается коммит с заголовком __fixup! заголовок нужного коммита__  
Дальше запускаем интерактивное перебазирование с аргументом `--autosquash`  
`git rebase -i --autosquash @~n`  (можно включить ее по умолчанию `git config --global rebase.autoSquash true` )  
Тогда откроется редактор __todo__ перебазирования, где можно увидеть этот коммит-закладку. И после перебазирования, этот коммит-закладка удалится.  

Можно также переименовать в ветке любой коммит  
`git commit -a --squash=commit_hash`  
`git rebase -i --autosquash before_commit_hash`  (здесь нужно указать коммит перед тем, который хотим менять, чтобы нужный попал в перебазирование)

## Rerere

Может возникнуть ситуция, когда конфликты решаются повторно. Например, мы сливали уже ветки, а потом решили перебазировать всю ветку на вершину __main__. Но так как определенный конфликт уже решали, то заново его решать не обязательно  
`git config rerere.enabled true` - включает его в опции и тогда он учится.  
Если до этого был выключен, то можно его запустить и научить, например, всем конфликтам  
`/path_to/rerere-train.sh`  
И теперь при последующих __rebase__ гит будет использовать опыт предыдущих подобных разрешений конфликтов.  

Если ветка несколько раз сливалась с __main__ и эти связи мешают, от них можно избавиться  
`git rebase commit_hash --no-ff` (тут мы выбираем общего родителя веток и заставляем заново перебазировать ветку, избавляясь от последующих связей с __main__. Без флага `--no-ff` гит не захочет этого делать, так как считает, что все и так ок)
