## Git Merge

Чтобы объединить одну ветку с другой, переходим на нужную ветку (master) и сливаем ее с нужной (fix)  
`git merge fix`  

Если прозошло слияние по алгоритму fast-forward, можно отменить слияние и вернуть указатель master на старый коммит  
Узнать его можно, выполнив команду `cat .git/ORIG_HEAD`  (не забыв уйти с master на другую ветку)  
`git branch -f master ORIG_HEAD`  

Чтобы найти коммит, где ветки разделяются, команда `git merge-base master feature`  
- __base__ - общий коммит
- __ours__ - где мы находимся
- __theirs__ - с чем сливаем

Состояние прерванного слияния при конфликте. Git запоминает последний коммит на такой стадии в директории .git/MERGE_HEAD

`git checkout --ours index.html` - вытащит то состояние, с ветки которой сливаем  

Если хотим посмотреть что сливается и решить, что оставить а что удалить  
`git checkout --merge index.html`  

Во время конфликта гит хранит информацию о всех сторонах конфликта. Можно посмотреть их так  
`git show :1:index.html` - общий предок  
`git show :2:index.html` - изменения на текущей ветке  
`git show :3:index.html` - изменения на сливаемой ветке  

Также в коммит слияния можно добавить текст предыдущих коммитов.  
`git merge --log=5` (указал ограничение в 5 прошлых коммитов)

`git reset --merge` - (или `git reset --abort`) оставляет изменения в файлах, которые не участвовали в слиянии. Если например, слияние происходит не на чистом статусе. С хард удалятся и незакомиченные изменения, а с флагом `--merge` только те, что участвовали в слиянии.  
`git reset --hard` - удаляет все изменения. 

Можно отменить коммит слияния, переместившись на предыдущий коммит  
`git reset @~ --hard` - откатится назад, отменив слияние  

В конце слияния образуется коммит слияния. Его особенность, что у него 2 родителя.
И `git show` покажет сокращенную версию, только то, где были конфликты.

Если нужно посмотреть, что было в файле до того, как ветки разделились  
`git checkout --conflict=diff3 --merge index.html`  
Также такое поведение можно поставить по умолчанию  
`git config --global merge.conflictStyle diff3`

Если гит намеривается слить ветки "перемоткой" (fast-forward), то можно запретить ему  
`git merge --no-ff feature ` (так как он просто перемещает указатель __main__ на коммит ветки __feature__ и все свалилось в одну кучу - а так ветка __feature__ остается отдельной)  
`git config merge.ff false` - настроит такое поведение по умолчанию  
Или же настроить конкретную ветку  
`git config branch.master.mergeoptions '--nof-ff'`   
`git merge feature -ff` - добавить обратно перемотку  

Если не нужна история всех изменения в сторонней ветке (адские эксперименты)  
`git merge --squash fix`  (не будет второго родителя - просто можно прописать коммит, а ветку удалить)
Но тут не будет MERGE_HEAD. И не сработает команда `git merge --abort` и `git merge --continue`. Но все также работает `git reset --merge`  

### Семантические конфликты и их разрешение
Например, мы изменили функцию в одной ветке (добавив аргумент), а коллега в другой ветке воспользовался этой функцией без аргумента не зная наших изменений. Получится merge коммит с ошибкой. В таком случае можно не коммитить при слиянии  
`git merge feature --no-commit`  
