//////////////////////////////////////////////////////////////////
-------REGULAG EXPRESSIONS---------;
const regexp = new RegExp('template', 'flags')
const regexp = /template/;


/./ - любой символ кроме \n

/////Символьные классы
\d => цифровой символ [0-9]
\D => не цифровой символ любой [^0-9]
\s => символ пробела (+\t\n\)
\S => непробельный символ [^ \r\t\f\n\v]
\w => цифры и английские буквы, символ нижнего подчеркивания [A-Za-z0-9_]
\W => [^a-zA-Z0-9_], например русская буква, '!$% etc'

//Наборы
[abc] - любой символ из набора
/[ЮИ]ра/ === Юра, Ира

//Исключающие наборы
[^abc] - исключающий набор
/[^ЮИ]ра/ - все кроме букв Ю и И

//Диапазоны
[a-cd-f]
[^a-cd-f]
//это диапазон не букв, а кодов этих символов
'а'.charCodeAt() => 1072
'я'.charCodeAt() => 1103
'ё'.charCodeAt() => 1105 - выходит за диапазон [а-я]

//квантификаторы
/\d{2}\.\d{2}\.\d{2}/ === /\d\d\.\d\d\.\d\d/ 

//жадные квантификаторы(стараются наибольшее количество раз повторить):
{n} - повторить n раз
/\d{3,4}/ - найти где цифра повторяется от 3 до 4 раз
//10000 => возьмет 1000(4 цифры), так как он жадный
{m, n} => повторить от m до n (жадная)
{m,} => жадный, нет верхней от границы, от m и больше
/colou?r/ => найдет color & colour

? => {0,1} квантификатор от 0 до 1
* => {0,} от нуля до бесконечности
+ => {1,} от одного до бесконечности

//ленивые квантификаторы
{m, n}? => ленивые квантификаторы(наименьшее)
{m,}? => ленивый, 
??
*? => от нуля до нуля
///\d*?/ (01234) => ""
+? => от одного до одного
///\d+?/ (01234) => 0 

/t[a-z]*i/ => 'titani' // Жадный, ищет до последнего i
/t[a-z]*?i/ => 'ti' // ленивый, ищет до первого i

//Флаги
g => С этим флагом поиск ищет все совпадения, без него – только первое.
s => Включает режим «dotall», при котором точка . может соответствовать символу перевода строки \n 
i => С этим флагом поиск не зависит от регистра: нет разницы между A и a
m => Многострочный режим
y => для поиска на заданной позиции lastIndex(если находит то останавливается)
// regextp.lastIndex = 1000;
// result = regexp.exec(string)
u => поддержка юникода и юникодных свойств

//юникодные свойства
/\p{Sc}/gu => ищет символы валюты. По умолчанию не поддерживаются. поэтому нужно указать флаг u


///якоря
^ => начало текста (или строки если есть флаг m)
$ => конец текста (или строки если есть флаг m)
\b => якорь границы слова между:
//1) ^ и \w
//2) \w and |W
//3) \W and \w
//4) \w and $
\B => не граница слова


let string = 'Here is the start,\nand here\nis the end.'
/^[^\s]+/g => перед скобками - якорь начала текста ('Here')
/[\s]+$/g => якорь конца текста ('end')
/^[^\s]+/gm => в начале каждой строчке(флаг m)(Here, and, is)
/[^\s]+$/gm => в конце каждой строчки('start,', 'here', 'end.')

//пример с якорем \b
let string = 'am .am,..programmer  am   Am'
console.log(string.match(/\bam\b/gi)) 
//["am", "am", "am", "Am"]
console.log(string.match(/\Bam\B/gi))
//["am"] - из слова programmer

// Parentheses 
let testStr = "Pumpkin";
let testRegex = /P(engu|umpk)in/;
testRegex.test(testStr);
// Returns true

// Reuse Patterns Using Capture Groups
let repeatStr = "regex regex";
let repeatRegex = /(\w+)\s\1/;
repeatRegex.test(repeatStr); // Returns true
repeatStr.match(repeatRegex); // Returns ["regex regex", "regex"]

let testString = "test test test";
let reRegex = /(test)(\s)\1\2\1/;
let result = reRegex.test(testString);
// result will match whole test test test because:
\1 repeats (test)
\2 repeats (\s)

// Replace
let str = "one two three";
let fixRegex = /(\w+)\s(\w+)\s(\w+)/; // Change this line
let replaceText = "$3 $2 $1"; // Change this line
let result = str.replace(fixRegex, replaceText); // three two one

//скобочные группы
//все, что в скобочной группе попадает в результат. чтобы не попадало - (?:)
// () => скобоыне группы
// (?:) => скобочная группа исключающая из запоминания
// \N => обратная ссылка в шаблоне, где N - номер скобочной группы
'/[a-f\d]{2}([-:])(?:[a-f\d]{2}\1){4}[a-f\d]{2}/gi'
//также можно сослаться на имя скобочной группы
// (?<name>) - именованная скобочная группа
// (\k<name>) - обратная ссылка в шаблоне
'/[a-f\d]{2}(?<separator>[-:])(?:[a-f\d]{2}\k<separator>){4}[a-f\d]{2}/gi'

const str = `
	ARP-таблица:
	Физический адрес	IP-адрес
	03-60-8с-01-02-03 	197.17.13.3
	00:01:A2:05:09:89 	197.17.13.44
	AA-00-22-6A:92-89 	197.17.13.123`

const regexp = /([a-f\d]{2}[-:]){5}[a-f\d]{2}/gi
const result = Array.from(str.matchAll(regexp))
=> ["00:01:A2:05:09:89", "09:"] тут попадает скобочная группа
/(?:[a-f\d]{2}[-:]){5}[a-f\d]{2}/gi => используем исключ символ
=> ["00:01:A2:05:09:89"] теперь все в порядке

//////////////////////////////////////////////////
//также у regexp есть два метода
//exec(str) - по очереди вызывает части итератора, если есть флаг _g_
//lastIndex - на чем итератор остановился

let string = 'Кот терракотового цвета кушает котлету'
let regexp = /кот/gi;

console.log(regexp.exec(string), regexp.lastIndex)
//["Кот", index: 0, input: "Кот терракотового цвета кушает котлету", groups: undefined] 3
console.log(regexp.exec(string), regexp.lastIndex)
//["кот", index: 9, input: "Кот терракотового цвета кушает котлету", groups: undefined] 12
console.log(regexp.exec(string), regexp.lastIndex)
//["кот", index: 31, input: "Кот терракотового цвета кушает котлету", groups: undefined] 34
console.log(regexp.exec(string), regexp.lastIndex)
//null 0

//чтобы вызвать этот итератор есть matchAll()
//но можно и самому
let result = []
let currentResult = null;
while(currentResult = regexp.exec(string)) {
	result = [...result, currentResult]
}


//альтернации
// | = или 
const regexp = /b|d/g
const str = 'abcdef'
console.log(str.match(regexp))
//["b", "d"]

const string = 'Завтрак в 09:15. Обед в 15:45. Ужин в 19:20.'
const regexp = /(?:[01]\d|2[0-3]):[0-5]\d/g
console.log(string.match(regexp))
//["09:15", "15:45", "19:20"]

//опережающие и ректроспективные проверки

//позитивная опережающая проверка
// Х(?=Y) => находит X, если за X следует Y 
const string = 'Ваш заказ 87, с вас 475 рублей... Вот ваша сдача 25 рублей'
const regexp = /\d+\b(?=\sрублей)/g
console.log(string.match(regexp))
//["475", "25"]

// негативная опережающая проверка
// X(?!Y) => найти X, за которым не следует Y
const string = 'Ваш заказ 87, с вас 475 рублей... Вот ваша сдача 25 рублей'
const regexp = /\d+\b(?!\sрублей)/g
console.log(string.match(regexp))
//["87"]

// позитивная ретроспективная проверка
// (?<=Y)X => найти X, если он следует за Y
const string = 'Ваш заказ 87, с вас 475 рублей... Вот ваша сдача 25 рублей'
const regexp = /(?<=заказ\s)\b\d+/g
console.log(string.match(regexp))
//["87"]

// негативная ретроспективная проверка
// (?<!Y)X => найти X, если он не следует за Y
const string = 'Ваш заказ 87, с вас 475 рублей... Вот ваша сдача 25 рублей'
const regexp = /(?<!заказ\s)\b\d+/g
console.log(string.match(regexp))
//["475", "25"]

const regexp = /[a-zA-Z\d]/g
const str = `
a B
aa aB Ba BB
1aa a1a aa1
1aB a1B aB1
1BB B1B BB1
`

// проверка - одна цифра, одна заглавная, 
const regexp = /^(?=[A-Z\d]*?[a-z])(?=[a-z\d]*?[A-Z])(?=[a-zA-Z]*?\d)[a-zA-Z\d]{8,16}$/

// Валидация пароля (1 загл, 1 проп, 1 цифра, от 6)
/^(?=.*[a-z])(?=.*[A-Z])(?=.*[\d])[a-zA-Z\d]{6,}$

// Это можно представить в виде
if(
  /[a-z]/.test(str)
  && /[A-Z]/.test(str)
  && /\d/.test(str)
  && /^[a-zA-Z\d]{6,}$/.test(str)
)

// Также опережающая проверка может проверять, даже если X нет
"helloMyNameIsSlimShady".split(/(?=[A-Z])/g)

["hello", "My", "Name", "Is", "Slim", "Shady"]

// (?=) ищет, начиная с текущей позиции в строке, но по результатам поиска текущую позицию не меняет.
// Соответственно, ^ означает, что поиск начинается с начала строки.
// И если первый (?=) завершается успехом, срабатывает второй (?=) - опять с начала строки, а потом и третий - тоже с начала строки.
// А после завершения успехом всех трёх (?=), срабатывает - опять же, с начала строки - [a-zA-Z\d]{6,}$
  
	